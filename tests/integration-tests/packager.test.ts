import fs from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';
import process from 'node:process';
import { afterEach, beforeEach, describe, expect, test } from 'vitest';
import { loadFileConfig, mergeConfigs } from '../../src/config/configLoad.js';
import type { repofmConfigFile, repofmConfigMerged, repofmOutputStyle } from '../../src/config/configSchema.js';
import { pack } from '../../src/core/packager.js';
import { isWindows } from '../testing/testUtils.js';




const fixturesDir = path.join(__dirname, 'fixtures', 'packager');
const inputsDir = path.join(fixturesDir, 'inputs');
const outputsDir = path.join(fixturesDir, 'outputs');

describe.runIf(!isWindows)('packager integration', () => {
  const testCases = [
    { desc: 'simple plain style', input: 'simple-project', output: 'simple-project-output.txt', config: {} },
    {
      desc: 'simple xml style',
      input: 'simple-project',
      output: 'simple-project-output.xml',
      config: { output: { style: 'xml', filePath: 'simple-project-output.xml' } },
    },
  ];

  let tempDir: string;

  beforeEach(async () => {
    // Create a temporary directory for each test
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'repofm-test-'));
  });

  afterEach(async () => {
    // Clean up the temporary directory after each test
    await fs.rm(tempDir, { recursive: true, force: true });
  });

  for (const { desc, input, output, config } of testCases) {
    test(`should correctly pack ${desc}`, async () => {
      const inputDir = path.join(inputsDir, input);
      const expectedOutputPath = path.join(outputsDir, output);
      const actualOutputPath = path.join(tempDir, output);

      const fileConfig: repofmConfigFile = await loadFileConfig(inputDir, null);
      const mergedConfig: repofmConfigMerged = mergeConfigs(process.cwd(), fileConfig, {
        output: {
          filePath: actualOutputPath,
          style: (config.output?.style || 'plain') as repofmOutputStyle,
        },
      });

      // Run the pack function
      await pack(inputDir, mergedConfig);

      // Read the actual and expected outputs
      let actualOutput = await fs.readFile(actualOutputPath, 'utf-8');
      let expectedOutput = await fs.readFile(expectedOutputPath, 'utf-8');

      actualOutput = actualOutput.replace(/^Generated by repofm on:.*\n/gm, '');
      expectedOutput = expectedOutput.replace(/^Generated by repofm on:.*\n/gm, '');

      // Compare the outputs
      expect(actualOutput).toBe(expectedOutput);

      // Optionally, update the expected output if explicitly requested
      if (process.env.UPDATE_EXPECTED_OUTPUT) {
        await fs.writeFile(expectedOutputPath, actualOutput);
        console.log(`Updated expected output for ${desc}`);
      }
    });
  }
});


// tests/integration-tests/packager.test.ts


describe('packager integration', () => {
  let tempDir: string;
  let fixturesDir: string;
  let inputsDir: string;
  let outputsDir: string;

  beforeEach(async () => {
    // 设置测试目录
    fixturesDir = path.join(__dirname, 'fixtures', 'packager');
    inputsDir = path.join(fixturesDir, 'inputs');
    outputsDir = path.join(fixturesDir, 'outputs');
    // 创建临时目录
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'repofm-test-'));
  });

  afterEach(async () => {
    // 清理临时目录
    await fs.rm(tempDir, { recursive: true, force: true });
  });

  describe('Basic Project Packing', () => {
    test('should pack simple project with default settings', async () => {
      // 复制简单项目到临时目录
      await copyDirectory(
        path.join(inputsDir, 'simple-project'),
        tempDir
      );

      // 加载配置
      const fileConfig: repofmConfigFile = await loadFileConfig(tempDir, null);
      const config: repofmConfigMerged = mergeConfigs(process.cwd(), fileConfig, {
        output: {
          filePath: path.join(tempDir, 'repofm-output.txt'),
          style: 'plain',
        },
      });

      // 执行打包
      await pack(tempDir, config);

      // 验证输出文件
      const output = await fs.readFile(path.join(tempDir, 'repofm-output.txt'), 'utf-8');
      const expected = await fs.readFile(
        path.join(outputsDir, 'simple-project-output.txt'),
        'utf-8'
      );

      // 清除时间戳等动态内容进行比较
      expect(normalizeOutput(output)).toBe(normalizeOutput(expected));
    });

    test('should pack simple project as XML', async () => {
      await copyDirectory(
        path.join(inputsDir, 'simple-project'),
        tempDir
      );

      const fileConfig: repofmConfigFile = await loadFileConfig(tempDir, null);
      const config: repofmConfigMerged = mergeConfigs(process.cwd(), fileConfig, {
        output: {
          filePath: path.join(tempDir, 'repofm-output.xml'),
          style: 'xml',
        },
      });

      await pack(tempDir, config);

      const output = await fs.readFile(path.join(tempDir, 'repofm-output.xml'), 'utf-8');
      const expected = await fs.readFile(
        path.join(outputsDir, 'simple-project-output.xml'),
        'utf-8'
      );

      expect(normalizeOutput(output)).toBe(normalizeOutput(expected));
    });

    test('should handle files with different encodings', async () => {
      // 创建测试文件
      await fs.writeFile(
        path.join(tempDir, 'utf8.txt'),
        'UTF-8 content'
      );
      await fs.writeFile(
        path.join(tempDir, 'gbk.txt'),
        Buffer.from('GBK content', 'utf8')  // 模拟GBK编码
      );

      const config = mergeConfigs(process.cwd(), {}, {});
      await pack(tempDir, config);

      const output = await fs.readFile(path.join(tempDir, config.output.filePath), 'utf-8');
      expect(output).toContain('UTF-8 content');
      expect(output).toContain('GBK content');
    });
  });

  describe('File Filtering', () => {
    test('should respect .gitignore patterns', async () => {
      // 创建测试项目结构
      await fs.mkdir(path.join(tempDir, 'src'), { recursive: true });
      await fs.writeFile(path.join(tempDir, 'src/index.js'), 'console.log("Hello");');
      await fs.writeFile(path.join(tempDir, '.gitignore'), 'node_modules/\n*.log');
      await fs.mkdir(path.join(tempDir, 'node_modules'), { recursive: true });
      await fs.writeFile(path.join(tempDir, 'node_modules/package.json'), '{}');
      await fs.writeFile(path.join(tempDir, 'app.log'), 'log content');

      const config = mergeConfigs(process.cwd(), {}, {});
      await pack(tempDir, config);

      const output = await fs.readFile(path.join(tempDir, config.output.filePath), 'utf-8');
      expect(output).toContain('src/index.js');
      expect(output).not.toContain('node_modules/package.json');
      expect(output).not.toContain('app.log');
    });

    test('should respect .repofmignore patterns', async () => {
      await fs.writeFile(path.join(tempDir, '.repofmignore'), 'ignored/\n*.test.js');
      await fs.mkdir(path.join(tempDir, 'ignored'), { recursive: true });
      await fs.writeFile(path.join(tempDir, 'ignored/file.js'), 'ignored content');
      await fs.writeFile(path.join(tempDir, 'app.test.js'), 'test content');
      await fs.writeFile(path.join(tempDir, 'app.js'), 'main content');

      const config = mergeConfigs(process.cwd(), {}, {});
      await pack(tempDir, config);

      const output = await fs.readFile(path.join(tempDir, config.output.filePath), 'utf-8');
      expect(output).toContain('app.js');
      expect(output).not.toContain('ignored/file.js');
      expect(output).not.toContain('app.test.js');
    });
  });

  describe('Security Checks', () => {
    test('should detect and exclude sensitive files', async () => {
      await fs.writeFile(
        path.join(tempDir, '.env'),
        'API_KEY=secret123\nDB_PASSWORD=password123'
      );
      await fs.writeFile(
        path.join(tempDir, 'config.js'),
        'export const apiKey = "secret456";'
      );

      const config = mergeConfigs(process.cwd(), {}, {
        security: {
          enableSecurityCheck: true,
        },
      });

      const { suspiciousFilesResults } = await pack(tempDir, config);

      expect(suspiciousFilesResults).toHaveLength(2);
      expect(suspiciousFilesResults[0].filePath).toContain('.env');
      expect(suspiciousFilesResults[1].filePath).toContain('config.js');
    });

    test('should respect security check disable option', async () => {
      await fs.writeFile(
        path.join(tempDir, '.env'),
        'API_KEY=secret123'
      );

      const config = mergeConfigs(process.cwd(), {}, {
        security: {
          enableSecurityCheck: false,
        },
      });

      const { suspiciousFilesResults } = await pack(tempDir, config);
      expect(suspiciousFilesResults).toHaveLength(0);
    });
  });

  describe('Large Projects', () => {
    test('should handle projects with many files', async () => {
      // 创建大量文件
      for (let i = 0; i < 1000; i++) {
        await fs.mkdir(path.join(tempDir, `dir${i}`), { recursive: true });
        await fs.writeFile(
          path.join(tempDir, `dir${i}`, `file${i}.js`),
          `console.log(${i});`
        );
      }

      const config = mergeConfigs(process.cwd(), {}, {});
      const { totalFiles } = await pack(tempDir, config);

      expect(totalFiles).toBe(1000);
    });

    test('should handle files with large content', async () => {
      const largeContent = 'x'.repeat(1024 * 1024); // 1MB content
      await fs.writeFile(path.join(tempDir, 'large.txt'), largeContent);

      const config = mergeConfigs(process.cwd(), {}, {});
      await pack(tempDir, config);

      const output = await fs.readFile(path.join(tempDir, config.output.filePath), 'utf-8');
      expect(output).toContain('large.txt');
      expect(output.length).toBeGreaterThan(1024 * 1024);
    });
  });

  describe('Custom Instructions', () => {
    test('should include custom instructions in output', async () => {
      await fs.writeFile(
        path.join(tempDir, 'instructions.md'),
        '# Custom Instructions\nFollow these steps...'
      );

      const config = mergeConfigs(process.cwd(), {}, {
        output: {
          instructionFilePath: 'instructions.md',
        },
      });

      await pack(tempDir, config);

      const output = await fs.readFile(path.join(tempDir, config.output.filePath), 'utf-8');
      expect(output).toContain('Custom Instructions');
      expect(output).toContain('Follow these steps');
    });
  });

  describe('Error Handling', () => {
    test('should handle permission errors gracefully', async () => {
      // 创建只读目录
      const readOnlyDir = path.join(tempDir, 'readonly');
      await fs.mkdir(readOnlyDir, { recursive: true });
      await fs.chmod(readOnlyDir, 0o444);

      const config = mergeConfigs(process.cwd(), {}, {});
      await expect(pack(readOnlyDir, config)).rejects.toThrow();
    });

    test('should handle invalid file paths', async () => {
      const config = mergeConfigs(process.cwd(), {}, {});
      await expect(pack('/nonexistent/dir', config)).rejects.toThrow();
    });
  });
});

// 辅助函数

async function copyDirectory(src: string, dest: string): Promise<void> {
  await fs.mkdir(dest, { recursive: true });
  const entries = await fs.readdir(src, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);

    if (entry.isDirectory()) {
      await copyDirectory(srcPath, destPath);
    } else {
      await fs.copyFile(srcPath, destPath);
    }
  }
}

function normalizeOutput(output: string): string {
  return output
    .replace(/Generated by repofm on: .*\n/g, '')
    .replace(/\r\n/g, '\n')
    .trim();
}
